<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bullen Audio Router</title>
  <style>
    :root { --bg: #0e1116; --fg: #e6e6e6; --muted: #999; --accent: #5ac8fa; --warn: #ff9f0a; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background: var(--bg); color: var(--fg); }
    header { padding: 12px 16px; border-bottom: 1px solid #222; display: flex; align-items: center; gap: 12px; }
    h1 { font-size: 18px; margin: 0; font-weight: 600; }
    main { padding: 16px; display: grid; gap: 16px; grid-template-columns: 1fr; max-width: 1100px; margin: 0 auto; }

    .panel { background: #141922; border: 1px solid #222; border-radius: 10px; padding: 16px; }
    .row { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    .spacer { flex: 1; }

    .channels { display: grid; grid-template-columns: repeat(6, 1fr); gap: 8px; }
    button { background: #1e2735; color: var(--fg); border: 1px solid #2a3550; padding: 8px 10px; border-radius: 8px; cursor: pointer; }
    button:hover { background: #233048; }
    button.sel { background: var(--accent); color: #000; border-color: var(--accent); }

    .mute { background: #2a1f1f; border-color: #473333; }
    .mute.on { background: #d43f3f; border-color: #d43f3f; color: #000; }

    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    .grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; }

    .slider { display: grid; grid-template-columns: 60px 1fr 80px; align-items: center; gap: 8px; }
    input[type="range"] { width: 100%; }

    .meter { height: 12px; background: #0b0f15; border: 1px solid #1b2230; border-radius: 6px; position: relative; overflow: hidden; }
    .meter .bar { position: absolute; left: 0; top: 0; bottom: 0; width: 0%; background: linear-gradient(90deg, #3ddc97, #ffd166, #ef476f); }
    .meter .peak { position: absolute; top: 0; bottom: 0; width: 2px; background: #ffd166; opacity: 0.9; }
    .label { font-size: 12px; color: var(--muted); }
    .small { font-size: 12px; color: var(--muted); }
    .card { padding: 12px; border: 1px solid #222; border-radius: 10px; background: #131722; }
  </style>
</head>
<body>
  <header>
    <h1>Bullen Audio Router</h1>
    <div class="spacer"></div>
    <div class="small">Selected: <span id="selected">-</span></div>
  </header>

  <main>
    <section class="panel">
      <div class="row" style="margin-bottom:8px;">
        <div class="label">Select channel</div>
      </div>
      <div class="channels" id="channelButtons"></div>
    </section>

    <section class="panel">
      <div class="row" style="margin-bottom:8px;">
        <div class="label">Gains & Mutes</div>
      </div>
      <div class="grid-3" id="gainMute"></div>
    </section>

    <section class="panel">
      <div class="row" style="margin-bottom:8px;">
        <div class="label">VU meters (RMS with peak marker)</div>
      </div>
      <div class="grid" id="meters"></div>
    </section>
  </main>

  <script>
    const N = 6;
    const channelButtons = document.getElementById('channelButtons');
    const meters = document.getElementById('meters');
    const gainMute = document.getElementById('gainMute');
    const selectedEl = document.getElementById('selected');

    // Build controls
    for (let i = 1; i <= N; i++) {
      const b = document.createElement('button');
      b.textContent = `CH ${i}`;
      b.id = `btn-${i}`;
      b.onclick = () => selectChannel(i);
      channelButtons.appendChild(b);

      const card = document.createElement('div');
      card.className = 'card';

      const row1 = document.createElement('div');
      row1.className = 'row';
      const mute = document.createElement('button');
      mute.textContent = 'Mute';
      mute.className = 'mute';
      mute.id = `mute-${i}`;
      mute.onclick = () => setMute(i, !(mute.classList.contains('on')));
      row1.appendChild(mute);
      card.appendChild(row1);

      const slider = document.createElement('div');
      slider.className = 'slider';
      const label = document.createElement('div'); label.textContent = `CH ${i}`; slider.appendChild(label);
      const range = document.createElement('input');
      range.type = 'range'; range.min = -60; range.max = 20; range.step = 0.5; range.value = 0; range.id = `gain-${i}`;
      range.oninput = () => setGainDb(i, parseFloat(range.value));
      slider.appendChild(range);
      const val = document.createElement('div'); val.className = 'small'; val.id = `gaindb-${i}`; val.textContent = '0.0 dB'; slider.appendChild(val);
      card.appendChild(slider);

      gainMute.appendChild(card);

      const mcard = document.createElement('div');
      mcard.className = 'card';
      const title = document.createElement('div'); title.className = 'small'; title.textContent = `CH ${i}`; mcard.appendChild(title);
      const meter = document.createElement('div'); meter.className = 'meter'; meter.id = `meter-${i}`;
      const bar = document.createElement('div'); bar.className = 'bar'; bar.id = `bar-${i}`; meter.appendChild(bar);
      const pk = document.createElement('div'); pk.className = 'peak'; pk.id = `peak-${i}`; meter.appendChild(pk);
      mcard.appendChild(meter);
      meters.appendChild(mcard);
    }

    // API helpers
    /**
     * Select a channel for monitoring
     * @param {number} ch - Channel number (1-based)
     */
    async function selectChannel(ch) {
      // Send POST request to select channel API endpoint
      await fetch(`/api/select/${ch}`, { method: 'POST' });
      // Update UI to highlight selected channel
      highlightSelected(ch);
    }

    /**
     * Set gain for a specific channel in decibels
     * @param {number} ch - Channel number (1-based)
     * @param {number} db - Gain value in decibels
     */
    async function setGainDb(ch, db) {
      // Send POST request to gain API endpoint with dB value
      await fetch(`/api/gain/${ch}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ gain_db: db }) });
      // Update gain display label with new value
      const el = document.getElementById(`gaindb-${ch}`); if (el) el.textContent = `${db.toFixed(1)} dB`;
    }

    /**
     * Set mute status for a specific channel
     * @param {number} ch - Channel number (1-based)
     * @param {boolean} on - Mute status (true for muted, false for unmuted)
     */
    async function setMute(ch, on) {
      // Send POST request to mute API endpoint with mute status
      await fetch(`/api/mute/${ch}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ mute: on }) });
      // Update mute button UI to reflect new status
      const btn = document.getElementById(`mute-${ch}`);
      if (btn) btn.classList.toggle('on', on);
    }

    /**
     * Highlight the selected channel in the UI
     * @param {number} ch - Channel number (1-based)
     */
    function highlightSelected(ch) {
      // Update selected channel display
      selectedEl.textContent = ch;
      // Toggle selected class on channel buttons
      for (let i = 1; i <= N; i++) {
        document.getElementById(`btn-${i}`).classList.toggle('sel', i === ch);
      }
    }

    /**
     * Convert linear value to decibels
     * @param {number} v - Linear value
     * @returns {number} Value in decibels
     */
    function vToDb(v) { const eps = 1e-9; return 20 * Math.log10(Math.max(eps, v)); }
    
    /**
     * Normalize dB value to range 0-1 for meter display
     * @param {number} db - Decibel value
     * @returns {number} Normalized value between 0 and 1
     */
    function normFromDb(db) { const minDb = -60; const maxDb = 0; return Math.max(0, Math.min(1, (db - minDb) / (maxDb - minDb))); }

    /**
     * Update VU meter displays with new values
     * @param {Object} vu - VU meter data object
     */
    function updateVU(vu) {
      // Extract VU data from payload
      const { vu_rms, vu_peak, selected_channel, mutes, gains_db } = vu;
      // Update selected channel highlight
      highlightSelected(selected_channel);
      // Update each channel's VU meter display
      for (let i = 1; i <= N; i++) {
        const idx = i - 1;
        // Convert RMS and peak values to decibels
        const rmsDb = vToDb(vu_rms[idx]);
        const pkDb = vToDb(vu_peak[idx]);
        // Get UI elements for this channel
        const bar = document.getElementById(`bar-${i}`);
        const pk = document.getElementById(`peak-${i}`);
        const muteBtn = document.getElementById(`mute-${i}`);
        const gainLabel = document.getElementById(`gaindb-${i}`);
        const gainSlider = document.getElementById(`gain-${i}`);
        // Update meter bar width based on RMS value
        if (bar) bar.style.width = `${(normFromDb(rmsDb) * 100).toFixed(1)}%`;
        // Update peak marker position
        if (pk) pk.style.left = `${(normFromDb(pkDb) * 100).toFixed(1)}%`;
        // Update mute button status
        if (muteBtn) muteBtn.classList.toggle('on', !!mutes[idx]);
        // Update gain display label
        if (gainLabel) gainLabel.textContent = `${(gains_db[idx]).toFixed(1)} dB`;
        // Update gain slider position
        if (gainSlider) gainSlider.value = gains_db[idx];
      }
    }

    /**
     * Initialize application state by fetching current engine state
     */
    async function initState() {
      // Fetch current engine state from API
      const r = await fetch('/api/state');
      // Parse JSON response
      const s = await r.json();
      // Update VU meters with initial state
      updateVU(s);
    }

    /**
     * Connect to WebSocket for VU meter updates
     */
    function wsConnect() {
      // Determine WebSocket protocol based on page protocol
      const proto = location.protocol === 'https:' ? 'wss' : 'ws';
      // Create WebSocket connection
      const ws = new WebSocket(`${proto}://${location.host}/ws/vu`);
      // Send ping message every 2 seconds to keep connection alive
      ws.onopen = () => { setInterval(() => { try { ws.send('ping'); } catch(e){} }, 2000); };
      // Handle incoming VU meter updates
      ws.onmessage = (ev) => { try { const data = JSON.parse(ev.data); updateVU(data); } catch(e){} };
      // Reconnect if connection is closed
      ws.onclose = () => { setTimeout(wsConnect, 2000); };
    }

    initState();
    wsConnect();
  </script>
</body>
</html>
