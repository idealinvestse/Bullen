<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bullen Audio Router</title>
  <link rel="stylesheet" href="/ui/css/styles.css" />
  <script src="/ui/js/api.js"></script>
  <script type="module">
    import { TestPanel } from './js/components/test-panel.js';
    import { DeveloperPanel } from './js/components/developer-panel.js';
    
    // Initialize components
    TestPanel.init();
    DeveloperPanel.init();
    
    // Noise suppression functions
    async function updateNoiseStatus() {
      try {
        const response = await fetch('/api/noise_suppression/status');
        const status = await response.json();
        
        const statusEl = document.getElementById('noise-status');
        if (statusEl) {
          statusEl.textContent = status.enabled ? 'Aktiverad' : 'Inaktiverad';
        }
        
        const slider = document.getElementById('noise-aggressiveness');
        if (slider && status.aggressiveness !== undefined) {
          slider.value = status.aggressiveness * 100;
          const levelEl = document.getElementById('noise-level');
          if (levelEl) {
            levelEl.textContent = Math.round(status.aggressiveness * 100) + '%';
          }
        }
      } catch (error) {
        console.debug('Noise suppression status not available:', error);
      }
    }
    
    window.applyNoiseSettings = async function() {
      const slider = document.getElementById('noise-aggressiveness');
      const level = slider.value / 100;
      
      try {
        const response = await fetch('/api/noise_suppression/aggressiveness', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ level: level })
        });
        
        if (response.ok) {
          const levelEl = document.getElementById('noise-level');
          if (levelEl) {
            levelEl.textContent = Math.round(level * 100) + '%';
          }
        }
      } catch (error) {
        console.error('Failed to apply noise settings:', error);
      }
    };
    
    // Update slider display
    document.addEventListener('DOMContentLoaded', () => {
      const slider = document.getElementById('noise-aggressiveness');
      if (slider) {
        slider.addEventListener('input', (e) => {
          const levelEl = document.getElementById('noise-level');
          if (levelEl) {
            levelEl.textContent = e.target.value + '%';
          }
        });
      }
      
      // Initial load
      updateNoiseStatus();
    });
    
    // Advanced telemetry visualization
    let telemetryInterval = null;
    
    async function updateAdvancedTelemetry() {
      try {
        const response = await fetch('/api/advanced/metrics');
        const metrics = await response.json();
        
        if (!metrics.enabled || !metrics.processors_available) {
          document.getElementById('advanced-telemetry').style.display = 'none';
          return;
        }
        
        document.getElementById('advanced-telemetry').style.display = 'block';
        
        // Update health score
        if (metrics.telemetry) {
          const healthScore = Math.round(metrics.telemetry.health_score);
          document.getElementById('health-score').querySelector('.score-value').textContent = healthScore;
          document.getElementById('xrun-count').textContent = metrics.telemetry.xrun_count;
          
          const avgThd = metrics.telemetry.thd.reduce((a, b) => a + b, 0) / metrics.telemetry.thd.length;
          document.getElementById('avg-thd').textContent = avgThd.toFixed(1);
          
          const avgSnr = metrics.telemetry.snr.reduce((a, b) => a + b, 0) / metrics.telemetry.snr.length;
          document.getElementById('avg-snr').textContent = avgSnr.toFixed(1);
        }
        
        // Update scene detection
        if (metrics.scene) {
          document.getElementById('scene-type').textContent = metrics.scene.current_scene;
          const confidence = Math.round(metrics.scene.confidence * 100);
          document.getElementById('scene-confidence').style.width = confidence + '%';
          document.getElementById('scene-confidence-text').textContent = confidence + '%';
        }
        
        // Update adaptive processing visualization
        if (metrics.adaptive) {
          const canvas = document.getElementById('adaptive-canvas');
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          
          // Draw adaptive gains
          const barWidth = canvas.width / metrics.adaptive.gains.length;
          metrics.adaptive.gains.forEach((gain, i) => {
            const height = gain * canvas.height * 0.8;
            ctx.fillStyle = `hsl(${240 + i * 20}, 70%, 60%)`;
            ctx.fillRect(i * barWidth, canvas.height - height, barWidth - 2, height);
          });
        }
        
        // Update mix weights visualization
        if (metrics.mixer) {
          const canvas = document.getElementById('mix-canvas');
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          
          // Draw mix weights
          const barWidth = canvas.width / metrics.mixer.mix_weights.length;
          metrics.mixer.mix_weights.forEach((weight, i) => {
            const height = weight * canvas.height;
            ctx.fillStyle = `hsl(${120 + i * 30}, 70%, 50%)`;
            ctx.fillRect(i * barWidth, canvas.height - height, barWidth - 2, height);
          });
        }
        
        // Update psychoacoustic visualization
        if (metrics.psychoacoustic) {
          const canvas = document.getElementById('bark-canvas');
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          
          // Draw masking threshold
          const barWidth = canvas.width / metrics.psychoacoustic.masking_threshold.length;
          metrics.psychoacoustic.masking_threshold.forEach((threshold, i) => {
            const height = Math.min(threshold * 1000, canvas.height);
            ctx.fillStyle = `rgba(103, 126, 234, ${0.3 + threshold})`;
            ctx.fillRect(i * barWidth, canvas.height - height, barWidth - 1, height);
          });
        }
        
        // Update resource management
        if (metrics.buffer_management) {
          document.getElementById('buffer-size').textContent = metrics.buffer_management.recommended_buffer_size;
          const headroom = Math.round(metrics.buffer_management.processing_headroom * 100);
          document.getElementById('processing-headroom').textContent = headroom;
          const latency = (metrics.buffer_management.mean_processing_time * 1000).toFixed(2);
          document.getElementById('processing-latency').textContent = latency;
        }
        
      } catch (error) {
        console.debug('Advanced telemetry not available:', error);
      }
    }
    
    // Start telemetry updates when advanced features are enabled
    async function checkAdvancedFeatures() {
      const response = await fetch('/api/config');
      const config = await response.json();
      
      if (config.enable_advanced_features) {
        updateAdvancedTelemetry();
        telemetryInterval = setInterval(updateAdvancedTelemetry, 1000);
      }
    }
    
    checkAdvancedFeatures();
  </script>
  <script type="module" src="/ui/js/app.js"></script>
</head>
<body>
  <header>
    <h1>Bullen Audio Router</h1>
    <div class="spacer"></div>
    <div class="small">Selected: <span id="selected">-</span></div>
    <div class="small" id="wsStatus" role="status" aria-live="polite" style="margin-left:8px;">WS: ‚Ä¶</div>
    <button id="settingsBtn" onclick="toggleSettings()" style="margin-left: 8px;">‚öôÔ∏è Settings</button>
    <button id="testBtn" onclick="toggleTestView()" style="margin-left: 8px;">üîä Test</button>
  </header>

  <main id="mainView" role="main" aria-label="Monitor">
    <section class="panel">
      <div class="row" style="margin-bottom:8px;">
        <div class="label">Select channel</div>
        <div class="info-icon" onclick="showInfo('channel')" title="Click for more info">‚ÑπÔ∏è</div>
      </div>
      <div class="channels" id="channelButtons"></div>
    </section>

    <section class="panel">
      <div class="row" style="margin-bottom:8px;">
        <div class="label">Gains & Mutes</div>
        <div class="info-icon" onclick="showInfo('gain')" title="Click for more info">‚ÑπÔ∏è</div>
      </div>
      <div class="grid-3" id="gainMute"></div>
    </section>

    <section class="panel">
      <div class="row" style="margin-bottom:8px;">
        <div class="label">VU meters (RMS with peak marker)</div>
        <div class="info-icon" onclick="showInfo('vu')" title="Click for more info">‚ÑπÔ∏è</div>
      </div>
      <div class="grid" id="meters"></div>
    </section>
  </main>

  <main id="settingsView" role="main" aria-label="Settings" style="display: none;">
    <section class="panel">
      <div class="row" style="margin-bottom:16px;">
        <h2 style="margin: 0; font-size: 20px;">Inst√§llningar & Information</h2>
        <div class="spacer"></div>
        <button onclick="toggleSettings()">‚Üê Tillbaka</button>
      </div>
      
      <div class="settings-content">
        <div class="setting-section">
          <h3>Kanalval</h3>
          <p>V√§lj vilken av de 6 ing√•ngskanalerna som ska skickas till h√∂rlurarna (L/R monitor). Den valda kanalen h√∂rs i b√•da √∂ronsn√§ckorna.</p>
          <ul>
            <li><strong>CH 1-6:</strong> Motsvarar fysiska ing√•ngar p√• Audio Injector Octo</li>
            <li><strong>Snabb v√§xling:</strong> Klicka p√• kanalknapparna f√∂r omedelbar v√§xling</li>
            <li><strong>Bl√• markering:</strong> Visar aktiv kanal</li>
          </ul>
        </div>

        <div class="setting-section">
          <h3>Gain & Mute</h3>
          <p>Justera volym och tysta individuella kanaler. Gain p√•verkar b√•de monitor och inspelning.</p>
          <ul>
            <li><strong>Gain-reglage:</strong> -60 dB till +20 dB, justeras i 0.5 dB-steg</li>
            <li><strong>Mute-knapp:</strong> R√∂d = tystad, gr√• = aktiv</li>
            <li><strong>Realtidsuppdatering:</strong> √Ñndringar till√§mpas omedelbart</li>
            <li><strong>Inspelning:</strong> Sker f√∂re gain/mute f√∂r att bevara originalljud</li>
          </ul>
        </div>

        <div class="setting-section">
          <h3>VU-m√§tare</h3>
          <p>Visar ljudniv√•er i realtid med b√•de RMS (genomsnittsniv√•) och peak (toppv√§rden).</p>
          <ul>
            <li><strong>Gr√∂n zon:</strong> Normala niv√•er (-60 till -20 dB)</li>
            <li><strong>Gul zon:</strong> H√∂ga niv√•er (-20 till -6 dB)</li>
            <li><strong>R√∂d zon:</strong> Risk f√∂r klippning (-6 till 0 dB)</li>
            <li><strong>Gul linje:</strong> Peak-mark√∂r visar h√∂gsta momentana niv√•</li>
            <li><strong>Uppdateringsfrekvens:</strong> ~20 Hz f√∂r smidig visning</li>
            <li><strong>Samplingsfrekvens:</strong> <span id="sampleRateInfo">-</span> Hz</li>
            <li><strong>Bufferstorlek:</strong> <span id="bufferSizeInfo">-</span> samples</li>
            <li><strong>Latens:</strong> ~<span id="latencyInfo">-</span> ms</li>
            <li><strong>Inspelning:</strong> <span id="recordingInfo">-</span></li>
          </ul>
        </div>

        <div class="setting-section">
          <h3>Systeminformation</h3>
          <div id="systemInfo">
            <p>Laddar systeminformation...</p>
          </div>
        </div>

        <div class="setting-section">
          <h3>Tekniska detaljer</h3>
          <ul>
            <li><strong>Audio backend:</strong> <span id="backendInfo">-</span></li>
          </ul>
        </div>
        
        <div class="setting-section">
          <h3>üîá Brusreducering f√∂r Callcenter</h3>
          <p>Avancerad brusreducering optimerad f√∂r callcenter-milj√∂er med flera operat√∂rer.</p>
          <div class="noise-control">
            <div class="control-item">
              <label>Status:</label>
              <span id="noise-status">Laddar...</span>
            </div>
            <div class="control-item">
              <label>Aggressivitet:</label>
              <input type="range" id="noise-aggressiveness" min="0" max="100" value="70" />
              <span id="noise-level">70%</span>
            </div>
            <div class="control-item">
              <button onclick="applyNoiseSettings()">Till√§mpa</button>
            </div>
          </div>
          <ul>
            <li><strong>0-30%:</strong> L√§tt filtrering - minimal p√•verkan p√• r√∂stkvalitet</li>
            <li><strong>40-70%:</strong> Balanserad - rekommenderat f√∂r callcenter</li>
            <li><strong>80-100%:</strong> Aggressiv - maximal brusreducering</li>
          </ul>
          <p><small>Anv√§nder VAD, spektral subtraktion, Wiener-filtrering och adaptiv korskanals-eliminering.</small></p>
        </div>
      </div>
    </section>
  </main>

  <main id="testView" role="main" aria-label="Tools & Tests" style="display: none;">
    <section class="panel">
      <div class="row" style="margin-bottom:16px;">
        <h2 style="margin: 0; font-size: 20px;">Ljudkanal-test</h2>
        <div class="spacer"></div>
        <button onclick="toggleTestView()">‚Üê Tillbaka</button>
      </div>
      
      <div class="test-content">
        <div class="test-info">
          <p>Denna vy visar alla 6 ljudkanaler samtidigt f√∂r att testa och √∂vervaka ljudstr√∂mmar i realtid.</p>
        </div>
        
        <div class="test-channels" id="testChannels">
          <!-- Channels will be populated by JavaScript -->
        </div>
        
        <div class="test-controls">
          <div class="control-section">
            <h3>Test-kontroller</h3>
            <div class="test-buttons">
              <button onclick="testAllChannels()" class="test-btn">üîä Testa alla kanaler</button>
              <button onclick="resetAllGains()" class="test-btn">üîÑ √Öterst√§ll gain</button>
              <button onclick="muteAllChannels()" class="test-btn mute-all">üîá Tysta alla</button>
              <button onclick="unmuteAllChannels()" class="test-btn">üîä Aktivera alla</button>
            </div>
          </div>
          
          <div class="control-section">
            <h3>VU-m√§tare inst√§llningar</h3>
            <div class="vu-controls">
              <label>
                <input type="checkbox" id="vuPeakHold" checked> H√•ll peak-v√§rden
              </label>
              <label>
                <input type="range" id="vuSensitivity" min="0.1" max="2" step="0.1" value="1"> K√§nslighet
              </label>
            </div>
          </div>
        </div>

        <div class="control-section">
          <h3>Developer Tools</h3>
          <div class="tabs" role="tablist" aria-label="Developer tools tabs">
            <button class="tab-btn active" role="tab" aria-selected="true" aria-controls="tabc-api" id="tab-api" onclick="DevTools.setTab('api')">API Console</button>
            <button class="tab-btn" role="tab" aria-selected="false" aria-controls="tabc-ws" id="tab-ws" onclick="DevTools.setTab('ws')">WS Inspector</button>
            <button class="tab-btn" role="tab" aria-selected="false" aria-controls="tabc-seq" id="tab-seq" onclick="DevTools.setTab('seq')">Sequences</button>
            <button class="tab-btn" role="tab" aria-selected="false" aria-controls="tabc-metrics" id="tab-metrics" onclick="DevTools.setTab('metrics')">Metrics</button>
          </div>

          <div id="tabc-api" class="tab-content active" role="tabpanel" aria-labelledby="tab-api">
            <div class="two-cols">
              <div>
                <div class="field"><label>Method</label>
                  <select id="apiMethod">
                    <option value="GET">GET</option>
                    <option value="POST">POST</option>
                  </select>
                </div>
                <div class="field"><label>Path</label>
                  <input id="apiPath" value="/api/state" placeholder="/api/state" />
                </div>
                <div class="field"><label>Body (JSON)</label>
                  <textarea id="apiBody" rows="8" placeholder="{ }"></textarea>
                </div>
                <div class="row" style="gap:8px; flex-wrap: wrap;">
                  <button class="test-btn" onclick="devSendApi()">Send</button>
                  <button class="test-btn" onclick="devFillApi('state')">/api/state</button>
                  <button class="test-btn" onclick="devFillApi('config')">/api/config</button>
                  <button class="test-btn" onclick="devFillApi('select')">select CH1</button>
                  <button class="test-btn" onclick="devFillApi('gaindb')">gain CH1 -6 dB</button>
                  <button class="test-btn" onclick="devFillApi('mute')">mute CH1</button>
                </div>
              </div>
              <div>
                <div class="field"><label>Status</label><input id="apiStatus" readonly /></div>
                <div class="field"><label>Time (ms)</label><input id="apiTime" readonly /></div>
                <div class="log" id="apiResponse" style="min-height: 200px;"></div>
              </div>
            </div>
          </div>

          <div id="tabc-ws" class="tab-content" role="tabpanel" aria-labelledby="tab-ws" hidden>
            <div class="row" style="gap:8px; margin-bottom:8px; flex-wrap: wrap;">
              <button class="test-btn" id="wsPauseBtn" onclick="devWsToggle()">Pause logging</button>
              <button class="test-btn" onclick="devWsClear()">Clear</button>
              <button class="test-btn" onclick="devWsCopyLast()">Copy last</button>
              <button class="test-btn" onclick="devWsDownload()">Download log</button>
            </div>
            <div class="two-cols">
              <div class="log" id="wsLog"></div>
              <div>
                <div class="field"><label>Total messages</label><input id="wsCount" readonly/></div>
                <div class="field"><label>Avg interval (ms)</label><input id="wsAvg" readonly/></div>
                <div class="field"><label>Min/Max interval (ms)</label><input id="wsMinMax" readonly/></div>
                <div class="field"><label>Approx rate (Hz)</label><input id="wsRate" readonly/></div>
                <div class="field"><label>Last received</label><input id="wsLastTime" readonly/></div>
              </div>
            </div>
          </div>

          <div id="tabc-seq" class="tab-content" role="tabpanel" aria-labelledby="tab-seq" hidden>
            <div class="two-cols">
              <div>
                <h4 style="margin:0 0 8px 0;">Cycle channels</h4>
                <div class="field"><label>Delay per channel (ms)</label><input id="seqCycleDelay" type="number" value="500"/></div>
                <div class="field"><label>Loops</label><input id="seqCycleLoops" type="number" value="1"/></div>
                <div class="row" style="gap:8px;"><button class="test-btn" onclick="devSeqStart('cycle')">Start</button></div>
              </div>
              <div>
                <h4 style="margin:0 0 8px 0;">Ramp gains</h4>
                <div class="field"><label>Min (dB)</label><input id="seqRampMin" type="number" value="-18"/></div>
                <div class="field"><label>Max (dB)</label><input id="seqRampMax" type="number" value="0"/></div>
                <div class="field"><label>Step (dB)</label><input id="seqRampStep" type="number" value="3"/></div>
                <div class="field"><label>Delay (ms)</label><input id="seqRampDelay" type="number" value="200"/></div>
                <div class="row" style="gap:8px;"><button class="test-btn" onclick="devSeqStart('ramp')">Start</button></div>
              </div>
            </div>
            <div class="two-cols" style="margin-top: 12px;">
              <div>
                <h4 style="margin:0 0 8px 0;">Mute/unmute all</h4>
                <div class="field"><label>Delay (ms)</label><input id="seqMuteDelay" type="number" value="500"/></div>
                <div class="row" style="gap:8px;">
                  <button class="test-btn" onclick="devSeqStart('mute')">Start</button>
                  <button class="test-btn danger" onclick="devSeqStopAll()">Stop all</button>
                </div>
              </div>
              <div>
                <h4 style="margin:0 0 8px 0;">Status</h4>
                <div class="log" id="seqStatus" style="min-height: 120px;"></div>
              </div>
            </div>
          </div>

          <div id="tabc-metrics" class="tab-content" role="tabpanel" aria-labelledby="tab-metrics" hidden>
            <div id="metricsContent" class="log" style="min-height:120px;"></div>
          </div>
        </div>
        
        <div class="control-section">
          <h3>Testljud</h3>
          <div class="row" style="gap:8px; flex-wrap: wrap; margin-bottom: 8px;">
            <button class="test-btn" onclick="genTestWavs()">üéµ Generera test-WAVs</button>
            <button class="test-btn" onclick="refreshWavsList()">‚Üª Uppdatera lista</button>
            <button class="test-btn danger" onclick="stopAllFeeds()">‚õî Stoppa alla feedar</button>
          </div>
          <div class="two-cols">
            <div>
              <h4 style="margin:0 0 8px 0;">Inljud (mata in till kanal)</h4>
              <div class="field"><label>Kanal</label>
                <select id="inFeedChannel" onchange="onInChannelChange()"></select>
              </div>
              <div class="field"><label>Fil</label>
                <select id="inFeedFile"></select>
              </div>
              <div class="field"><label>Loop</label>
                <select id="inFeedLoop"><option value="true" selected>Ja</option><option value="false">Nej</option></select>
              </div>
              <div class="field"><label>Gain (dB)</label>
                <input id="inFeedGain" type="number" value="0" />
              </div>
              <div class="row" style="gap:8px;">
                <button class="test-btn" onclick="startFeedSelected()">Starta feed</button>
                <button class="test-btn" onclick="stopFeedSelected()">Stoppa feed</button>
              </div>
              <div class="row" style="gap:8px; margin-top:8px;">
                <button class="test-btn" onclick="feedSequence()">‚ñ∂ Feed-sekvens 1..6</button>
              </div>
            </div>
            <div>
              <h4 style="margin:0 0 8px 0;">Utljud (8 kanaler)</h4>
              <div class="field"><label>F√∂rdr√∂jning per kanal (ms)</label>
                <input id="outCycleDelay" type="number" value="800" />
              </div>
              <div class="row" style="gap:8px;">
                <button class="test-btn" onclick="headsetCycle()">‚ñ∂ Cykla ut (1..6)</button>
                <button class="test-btn" onclick="feedAndHeadsetSequence()">‚ñ∂ Feed + v√§lj kanal</button>
              </div>
              <div class="row" style="gap:8px; margin-top:8px;">
                <button class="test-btn" onclick="testAllOutputChannels()">üîä Testa alla 8 utg√•ngar</button>
                <button class="test-btn" onclick="testSpecificOutput()">üéØ Testa specifik utg√•ng</button>
              </div>
              <div class="row" style="gap:8px; margin-top:8px;">
                <button class="test-btn" onclick="runAutomaticOutputTest()">ü§ñ Automatiskt ljudtest</button>
                <button class="test-btn" onclick="generateTestAudio()">üéµ Generera testljud</button>
              </div>
              <div class="field" style="margin-top:8px;">
                <label>Utg√•ngskanal att testa</label>
                <select id="outputChannelSelect">
                  <option value="1">Utg√•ng 1 (out_l)</option>
                  <option value="2">Utg√•ng 2 (out_r)</option>
                  <option value="3">Utg√•ng 3</option>
                  <option value="4">Utg√•ng 4</option>
                  <option value="5">Utg√•ng 5</option>
                  <option value="6">Utg√•ng 6</option>
                  <option value="7">Utg√•ng 7</option>
                  <option value="8">Utg√•ng 8</option>
                </select>
              </div>
              <div class="log" id="testAudioLog" style="margin-top:8px; min-height: 80px;"></div>
            </div>
          </div>
        </div>
        
        <div class="control-section">
          <h3>üéµ Ladda upp egen ljudfil</h3>
          <div class="two-cols">
            <div>
              <h4 style="margin:0 0 8px 0;">Ladda upp fil</h4>
              <div class="field">
                <label>V√§lj ljudfil</label>
                <input type="file" id="audioFileInput" accept=".wav,.mp3,.ogg,.flac,.m4a,.aac" onchange="handleFileSelect(event)" />
              </div>
              <div id="uploadStatus" style="margin: 8px 0; color: var(--muted); font-size: 12px;"></div>
              <div class="row" style="gap:8px;">
                <button class="test-btn" onclick="uploadSelectedFile()">üì§ Ladda upp</button>
                <button class="test-btn" onclick="refreshUploadedFiles()">‚Üª Uppdatera lista</button>
              </div>
            </div>
            <div>
              <h4 style="margin:0 0 8px 0;">Uppladdade filer</h4>
              <div class="field">
                <label>V√§lj fil</label>
                <select id="uploadedFilesList" onchange="selectUploadedFile()"></select>
              </div>
              <div id="uploadedFileInfo" style="margin: 8px 0; color: var(--muted); font-size: 12px;"></div>
              <div class="row" style="gap:8px;">
                <button class="test-btn" onclick="playUploadedFile()">‚ñ∂ Spela p√• kanal</button>
                <button class="test-btn danger" onclick="deleteUploadedFile()">üóëÔ∏è Ta bort</button>
              </div>
            </div>
          </div>
          <div style="margin-top: 16px;">
            <h4 style="margin:0 0 8px 0;">Spela uppladdat ljud</h4>
            <div class="two-cols">
              <div class="field">
                <label>Kanal att spela p√•</label>
                <select id="uploadPlayChannel">
                  <option value="1">Kanal 1</option>
                  <option value="2">Kanal 2</option>
                  <option value="3">Kanal 3</option>
                  <option value="4">Kanal 4</option>
                  <option value="5">Kanal 5</option>
                  <option value="6">Kanal 6</option>
                </select>
              </div>
              <div class="field">
                <label>Loop</label>
                <select id="uploadPlayLoop">
                  <option value="true" selected>Ja</option>
                  <option value="false">Nej</option>
                </select>
              </div>
              <div class="field">
                <label>Gain (dB)</label>
                <input id="uploadPlayGain" type="number" value="0" min="-60" max="20" />
              </div>
              <div class="row" style="gap:8px;">
                <button class="test-btn" onclick="startUploadedPlayback()">‚ñ∂ Starta uppspelning</button>
                <button class="test-btn" onclick="stopUploadedPlayback()">‚èπ Stoppa uppspelning</button>
              </div>
            </div>
            <div class="log" id="uploadPlayLog" style="margin-top:8px; min-height: 60px;"></div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <script>
    // Toast notifications
    function showToast(message, type = 'info') {
      let cont = document.getElementById('toastContainer');
      if (!cont) {
        cont = document.createElement('div');
        cont.id = 'toastContainer';
        cont.className = 'toast-container';
        cont.setAttribute('aria-live', 'assertive');
        cont.setAttribute('aria-atomic', 'true');
        document.body.appendChild(cont);
      }
      const t = document.createElement('div');
      t.className = `toast toast--${type}`;
      t.textContent = message;
      cont.appendChild(t);
      setTimeout(() => { try { cont.removeChild(t); } catch(_){} }, 3000);
    }
    let N = 6;
    let CONFIG = null;
    const channelButtons = document.getElementById('channelButtons');
    const meters = document.getElementById('meters');
    const gainMute = document.getElementById('gainMute');
    const selectedEl = document.getElementById('selected');
    const wsStatusEl = document.getElementById('wsStatus');
    let _vuPending = null;
    let _vuRaf = null;

    // Helpers
    function debounce(fn, wait) {
      let t = null, lastArgs = null;
      return function(...args) {
        lastArgs = args;
        if (t) clearTimeout(t);
        t = setTimeout(() => { t = null; fn.apply(this, lastArgs); }, wait);
      };
    }
    function normFromDb(db) {
      // Map -60..0 dB -> 0..1 linearly; clamp outside range
      const minDb = -60, maxDb = 0;
      const cl = Math.max(minDb, Math.min(maxDb, db));
      return (cl - minDb) / (maxDb - minDb);
    }
    const _gainDebounced = {};
    function debouncedGain(ch) {
      if (!_gainDebounced[ch]) _gainDebounced[ch] = debounce((v) => setGainDb(ch, v), 150);
      return _gainDebounced[ch];
    }

    // dB conversion helper
    function vToDb(v) {
      const eps = 1e-9;
      return 20 * Math.log10(Math.max(eps, v));
    }

    // Test view helpers
    function updateTestGainDisplay(ch, val) {
      const el = document.getElementById(`test-gain-value-${ch}`);
      if (el) el.textContent = `${parseFloat(val).toFixed(1)} dB`;
    }
    async function toggleChannelMute(ch) {
      const btn = document.getElementById(`test-mute-${ch}`);
      const current = btn ? btn.classList.contains('on') : false;
      try { await setMute(ch, !current); } catch(_) {}
    }

    // Info popovers
    function showInfo(kind) {
      const map = {
        channel: 'V√§lj vilken ing√•ng som ska monitoreras i headset.',
        gain: 'Justera per-kanals gain i dB. Mute tystar kanalen.',
        vu: 'RMS-bar och peak-mark√∂r i dB (‚Äë60 till 0 dB).',
      };
      showToast(map[kind] || 'Info', 'success');
    }

    function buildUI(n) {
      // clear containers first (in case of rebuild)
      channelButtons.innerHTML = '';
      gainMute.innerHTML = '';
      meters.innerHTML = '';
      for (let i = 1; i <= n; i++) {
        const b = document.createElement('button');
        b.textContent = `CH ${i}`;
        b.id = `btn-${i}`;
        b.onclick = () => selectChannel(i);
        b.setAttribute('aria-label', `Select channel ${i}`);
        b.setAttribute('aria-pressed', 'false');
        channelButtons.appendChild(b);

        const card = window.BullenComponents.buildGainMuteCard(i, {
          onMute: (ch, on) => setMute(ch, on),
          onGainDb: (ch, val) => debouncedGain(ch)(val)
        });
        gainMute.appendChild(card);

        const mcard = window.BullenComponents.buildVuMeter(i);
        meters.appendChild(mcard);
      }
    }

    // Coalesce VU updates to animation frames for smoother UI and fewer layout passes
    function scheduleVU(vu) {
      _vuPending = vu;
      if (_vuRaf) return;
      _vuRaf = requestAnimationFrame(() => {
        _vuRaf = null;
        if (_vuPending) {
          const data = _vuPending; _vuPending = null;
          updateVU(data);
          // Also update test view if visible
          const testView = document.getElementById('testView');
          if (testView && testView.style.display !== 'none') { try { updateTestVU(data); } catch(_){} }
        }
      });
    }

    // API helpers
    /**
     * Select a channel for monitoring
     * @param {number} ch - Channel number (1-based)
     */
    async function selectChannel(ch) {
      try {
        await window.BullenAPI.selectChannel(ch);
        highlightSelected(ch);
      } catch (e) {
        if (wsStatusEl) { wsStatusEl.textContent = `API error: select ${ch}`; wsStatusEl.style.color = '#ef476f'; }
        console.error('selectChannel failed', e);
      }
    }

    /**
     * Set gain for a specific channel in decibels
     * @param {number} ch - Channel number (1-based)
     * @param {number} db - Gain value in decibels
     */
    async function setGainDb(ch, db) {
      try {
        await window.BullenAPI.setGainDb(ch, db);
        const el = document.getElementById(`gaindb-${ch}`); if (el) el.textContent = `${db.toFixed(1)} dB`;
      } catch (e) {
        if (wsStatusEl) { wsStatusEl.textContent = `API error: gain CH${ch}`; wsStatusEl.style.color = '#ef476f'; }
        showToast(`Misslyckades att s√§tta gain f√∂r CH${ch}`, 'error');
        console.error('setGainDb failed', e);
      }
    }

    /**
     * Set mute status for a specific channel
     * @param {number} ch - Channel number (1-based)
     * @param {boolean} on - Mute status (true for muted, false for unmuted)
     */
    async function setMute(ch, on) {
      try {
        await window.BullenAPI.setMute(ch, on);
        const btn = document.getElementById(`mute-${ch}`);
        if (btn) btn.classList.toggle('on', on);
      } catch (e) {
        if (wsStatusEl) { wsStatusEl.textContent = `API error: mute CH${ch}`; wsStatusEl.style.color = '#ef476f'; }
        showToast(`Misslyckades att muta CH${ch}`, 'error');
        console.error('setMute failed', e);
      }
    }

    /**
     * Highlight the selected channel in the UI
     * @param {number} ch - Channel number (1-based)
     */
    function highlightSelected(ch) {
      // Update selected channel display
      selectedEl.textContent = ch;
      // Toggle selected class on channel buttons
      for (let i = 1; i <= N; i++) {
        const btn = document.getElementById(`btn-${i}`);
        if (!btn) continue;
        const isSel = i === ch;
        btn.classList.toggle('sel', isSel);
        btn.setAttribute('aria-pressed', isSel ? 'true' : 'false');
      }
    }

    /**
     * Convert linear value to decibels
     * @param {number} v - Linear value
     * @returns {number} Value in decibels
     */
    function vToDb(v) { const eps = 1e-9; return 20 * Math.log10(Math.max(eps, v)); }
    
    /**
     * Normalize dB value to range 0-1 for meter display
     * @param {number} db - Decibel value
     * @returns {number} Normalized value between 0 and 1
     */
    function normFromDb(db) { const minDb = -60; const maxDb = 0; return Math.max(0, Math.min(1, (db - minDb) / (maxDb - minDb))); }

    /**
     * Update VU meter displays with new values
     * @param {Object} vu - VU meter data object
     */
    function updateVU(vu) {
      // Extract VU data from payload
      const { vu_rms, vu_peak, selected_channel, mutes, gains_db } = vu;
      // Update selected channel highlight
      highlightSelected(selected_channel);
      // Update each channel's VU meter display
      for (let i = 1; i <= N; i++) {
        const idx = i - 1;
        // Convert RMS and peak values to decibels
        const rmsDb = vToDb(vu_rms[idx]);
        const pkDb = vToDb(vu_peak[idx]);
        // Get UI elements for this channel
        const bar = document.getElementById(`bar-${i}`);
        const pk = document.getElementById(`peak-${i}`);
        const muteBtn = document.getElementById(`mute-${i}`);
        const gainLabel = document.getElementById(`gaindb-${i}`);
        const gainSlider = document.getElementById(`gain-${i}`);
        // Update meter bar width based on RMS value
        if (bar) bar.style.width = `${(normFromDb(rmsDb) * 100).toFixed(1)}%`;
        // Update peak marker position
        if (pk) pk.style.left = `${(normFromDb(pkDb) * 100).toFixed(1)}%`;
        // Update mute button status
        if (muteBtn) muteBtn.classList.toggle('on', !!mutes[idx]);
        if (muteBtn) muteBtn.setAttribute('aria-pressed', !!mutes[idx] ? 'true' : 'false');
        // Update gain display label
        if (gainLabel) gainLabel.textContent = `${(gains_db[idx]).toFixed(1)} dB`;
        // Update gain slider position
        if (gainSlider) gainSlider.value = gains_db[idx];
      }
    }

    /**
     * Initialize application state by fetching current engine state
     */
    async function initState() {
      try {
        const s = await window.BullenAPI.getState();
        updateVU(s);
      } catch (e) {
        if (wsStatusEl) { wsStatusEl.textContent = 'API error: state'; wsStatusEl.style.color = '#ef476f'; }
        showToast('Kunde inte h√§mta systemstatus', 'error');
        console.error('initState failed', e);
      }
    }

    /**
     * Connect to WebSocket for VU meter updates
     */
    function wsConnect() {
      window.BullenWS.connect({
        onStatus: (s) => {
          if (!wsStatusEl) return;
          if (s === 'connected') { wsStatusEl.textContent = 'WS: connected'; wsStatusEl.style.color = '#3ddc97'; }
          else if (s === 'reconnecting') { wsStatusEl.textContent = 'WS: reconnecting‚Ä¶'; wsStatusEl.style.color = '#ffd166'; }
          else if (s === 'error') { wsStatusEl.textContent = 'WS: error'; wsStatusEl.style.color = '#ef476f'; }
        },
        onMessage: (data) => {
          try { if (typeof devOnWs === 'function') devOnWs(data); } catch(_){ }
          scheduleVU(data);
        }
      });
    }

    async function init() {
      try {
        CONFIG = await window.BullenAPI.getConfig();
        N = CONFIG.inputs || 6;
        buildUI(N);
      } catch(e) {
        buildUI(N);
        if (wsStatusEl) { wsStatusEl.textContent = 'API error: config'; wsStatusEl.style.color = '#ef476f'; }
        showToast('Kunde inte h√§mta konfiguration', 'error');
        console.error('getConfig failed', e);
      }
      await initState();
      wsConnect();
      // Keyboard shortcuts: 1-6 select, m mute toggle, ArrowUp/Down adjust gain 1 dB
      document.addEventListener('keydown', (e) => {
        const tag = (e.target && e.target.tagName) || '';
        if (tag === 'INPUT' || tag === 'TEXTAREA' || (e.target && e.target.isContentEditable)) return;
        // number keys 1..9
        if (/^[1-9]$/.test(e.key)) {
          const ch = parseInt(e.key, 10);
          if (ch >= 1 && ch <= N) { selectChannel(ch); e.preventDefault(); }
          return;
        }
        // mute toggle
        if (e.key === 'm' || e.key === 'M') {
          const ch = parseInt(selectedEl.textContent || '1', 10) || 1;
          const btn = document.getElementById(`mute-${ch}`);
          const on = !(btn && btn.classList.contains('on'));
          setMute(ch, on);
          e.preventDefault();
          return;
        }
        // gain up/down 1 dB
        if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
          const ch = parseInt(selectedEl.textContent || '1', 10) || 1;
          const slider = document.getElementById(`gain-${ch}`);
          if (slider) {
            const step = 1;
            const curr = parseFloat(slider.value);
            let next = curr + (e.key === 'ArrowUp' ? step : -step);
            next = Math.max(parseFloat(slider.min), Math.min(parseFloat(slider.max), next));
            slider.value = String(next);
            setGainDb(ch, next);
            e.preventDefault();
          }
        }
      });
      // Developer Tools tabs keyboard navigation (ArrowLeft/ArrowRight)
      const tablist = document.querySelector('.tabs[role="tablist"]');
      if (tablist) {
        const order = ['api','ws','seq','metrics'];
        tablist.addEventListener('keydown', (e) => {
          if (e.key !== 'ArrowLeft' && e.key !== 'ArrowRight') return;
          const currentId = (document.activeElement && document.activeElement.id) || 'tab-api';
          const currKey = currentId.startsWith('tab-') ? currentId.slice(4) : 'api';
          let idx = order.indexOf(currKey);
          if (idx < 0) idx = 0;
          idx = (e.key === 'ArrowRight') ? (idx + 1) % order.length : (idx - 1 + order.length) % order.length;
          DevTools.setTab(order[idx]);
          e.preventDefault();
        });
      }
    }

    window.BullenEntry = init;

    /**
     * Toggle between main view and settings view
     */
    function toggleSettings() {
      const mainView = document.getElementById('mainView');
      const settingsView = document.getElementById('settingsView');
      const isSettingsVisible = settingsView.style.display !== 'none';
      
      if (isSettingsVisible) {
        mainView.style.display = 'block';
        settingsView.style.display = 'none';
      } else {
        mainView.style.display = 'none';
        settingsView.style.display = 'block';
        loadSystemInfo();
      }
    }

    /**
     * Show information popup for specific feature
     * @param {string} type - Type of info to show
     */
    function showInfo(type) {
      const messages = {
        channel: 'Kanalval: V√§lj vilken ing√•ng som ska h√∂ras i h√∂rlurarna. Den valda kanalen (bl√•) skickas till b√•de v√§nster och h√∂ger h√∂rlurar.',
        gain: 'Gain & Mute: Justera volym (-60 till +20 dB) och tysta kanaler. R√∂d mute-knapp = tystad. Gain p√•verkar b√•de monitor och inspelning.',
        vu: 'VU-m√§tare: Gr√∂n = normalt, gul = h√∂gt, r√∂d = risk f√∂r klippning. Stapeln visar RMS-niv√•, gul linje visar peak-v√§rde.'
      };
      alert(messages[type] || 'Information inte tillg√§nglig.');
    }

    /**
     * Load system information for settings view
     */
    async function loadSystemInfo() {
      try {
        const [stateRes, configRes] = await Promise.all([
          fetch('/api/state'),
          fetch('/api/config')
        ]);
        const state = await stateRes.json();
        const config = await configRes.json();
        
        // Update system info elements
        document.getElementById('backendInfo').textContent = config.backend || 'jack';
        document.getElementById('sampleRateInfo').textContent = state.samplerate || '-';
        document.getElementById('bufferSizeInfo').textContent = state.frames_per_period || '-';
        
        // Calculate approximate latency
        const latency = state.samplerate && state.frames_per_period ? 
          ((state.frames_per_period * 2) / state.samplerate * 1000).toFixed(1) : '-';
        document.getElementById('latencyInfo').textContent = latency;
        
        document.getElementById('recordingInfo').textContent = state.recording ? 'Aktiverad' : 'Inaktiverad';
        
        // System info summary
        const systemInfoEl = document.getElementById('systemInfo');
        systemInfoEl.innerHTML = `
          <p><strong>Status:</strong> Ansluten och aktiv</p>
          <p><strong>Kanaler:</strong> ${config.inputs || 6} ing√•ngar, ${config.outputs || 8} utg√•ngar</p>
          <p><strong>Vald kanal:</strong> CH ${state.selected_channel || 1}</p>
          <p><strong>Inspelningar:</strong> ${config.recordings_dir || 'recordings'}/</p>
        `;
      } catch (error) {
        document.getElementById('systemInfo').innerHTML = '<p style="color: var(--warn);">Kunde inte ladda systeminformation</p>';
      }
    }

    /**
     * Toggle between main view and test view
     */
    function toggleTestView() {
      const mainView = document.getElementById('mainView');
      const settingsView = document.getElementById('settingsView');
      const testView = document.getElementById('testView');
      const isTestVisible = testView.style.display !== 'none';
      
      if (isTestVisible) {
        mainView.style.display = 'block';
        settingsView.style.display = 'none';
        testView.style.display = 'none';
      } else {
        mainView.style.display = 'none';
        settingsView.style.display = 'none';
        testView.style.display = 'block';
        initTestView();
      }
    }

    /**
     * Initialize test view with channel controls
     */
    function initTestView() {
      const testChannels = document.getElementById('testChannels');
      testChannels.innerHTML = '';
      
      for (let i = 1; i <= N; i++) {
        const channel = document.createElement('div');
        channel.className = 'test-channel';
        channel.id = `test-channel-${i}`;
        
        channel.innerHTML = `
          <h4>
            CH ${i}
            <span class="channel-status status-inactive" id="test-status-${i}">Inaktiv</span>
          </h4>
          
          <div class="test-meter" id="test-meter-${i}">
            <div class="bar" id="test-bar-${i}"></div>
            <div class="peak" id="test-peak-${i}"></div>
          </div>
          
          <div class="channel-gain">
            <input type="range" id="test-gain-${i}" min="-60" max="20" step="0.5" value="0" 
                   oninput="setGainDb(${i}, parseFloat(this.value)); updateTestGainDisplay(${i}, this.value)">
            <div class="gain-value" id="test-gain-value-${i}">0.0 dB</div>
          </div>
          
          <div class="channel-mute">
            <button class="mute" id="test-mute-${i}" onclick="toggleChannelMute(${i})">
              Mute CH ${i}
            </button>
          </div>
        `;
        
        testChannels.appendChild(channel);
      }
    }

    /**
     * Update test view with VU data
     */
    function updateTestVU(vu) {
      const { vu_rms, vu_peak, selected_channel, mutes, gains_db } = vu;
      const vuSensitivity = parseFloat(document.getElementById('vuSensitivity')?.value || 1);
      const peakHold = document.getElementById('vuPeakHold')?.checked || false;
      
      for (let i = 1; i <= N; i++) {
        const idx = i - 1;
        const rmsDb = vToDb(vu_rms[idx]) * vuSensitivity;
        const pkDb = vToDb(vu_peak[idx]) * vuSensitivity;
        
        // Update meters
        const bar = document.getElementById(`test-bar-${i}`);
        const peak = document.getElementById(`test-peak-${i}`);
        const status = document.getElementById(`test-status-${i}`);
        const channel = document.getElementById(`test-channel-${i}`);
        const muteBtn = document.getElementById(`test-mute-${i}`);
        const gainSlider = document.getElementById(`test-gain-${i}`);
        const gainValue = document.getElementById(`test-gain-value-${i}`);
        
        if (bar) bar.style.width = `${(normFromDb(rmsDb) * 100).toFixed(1)}%`;
        if (peak) {
          const peakPos = `${(normFromDb(pkDb) * 100).toFixed(1)}%`;
          if (!peakHold || parseFloat(peak.style.left || '0%') < parseFloat(peakPos)) {
            peak.style.left = peakPos;
          }
        }
        
        // Update status and highlighting
        if (status && channel) {
          const isActive = vu_rms[idx] > 0.001; // Threshold for "active"
          const isMuted = mutes[idx];
          const isSelected = i === selected_channel;
          
          if (isMuted) {
            status.textContent = 'Tystad';
            status.className = 'channel-status status-muted';
          } else if (isActive) {
            status.textContent = 'Aktiv';
            status.className = 'channel-status status-active';
          } else {
            status.textContent = 'Inaktiv';
            status.className = 'channel-status status-inactive';
          }
          
          channel.classList.toggle('active', isSelected);
        }
        
        // Update controls
        if (muteBtn) muteBtn.classList.toggle('on', mutes[idx]);
        if (gainSlider) gainSlider.value = gains_db[idx];
        if (gainValue) gainValue.textContent = `${gains_db[idx].toFixed(1)} dB`;
      }
    }

    /**
     * Update gain display in test view
     */
    function updateTestGainDisplay(ch, value) {
      const gainValue = document.getElementById(`test-gain-value-${ch}`);
      if (gainValue) gainValue.textContent = `${parseFloat(value).toFixed(1)} dB`;
    }

    /**
     * Toggle mute for a channel in test view
     */
    async function toggleChannelMute(ch) {
      const btn = document.getElementById(`test-mute-${ch}`);
      const isMuted = btn.classList.contains('on');
      await setMute(ch, !isMuted);
    }

    /**
     * Test all channels by cycling through them
     */
    async function testAllChannels() {
      for (let i = 1; i <= N; i++) {
        await selectChannel(i);
        await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second per channel
      }
    }

    /**
     * Reset all gains to 0 dB
     */
    async function resetAllGains() {
      for (let i = 1; i <= N; i++) {
        await setGainDb(i, 0);
        updateTestGainDisplay(i, 0);
      }
    }

    /**
     * Mute all channels
     */
    async function muteAllChannels() {
      for (let i = 1; i <= N; i++) {
        await setMute(i, true);
      }
    }

    /**
     * Unmute all channels
     */
    async function unmuteAllChannels() {
      for (let i = 1; i <= N; i++) {
        await setMute(i, false);
      }
    }

    // ----- Developer Tools -----
    const dev = {
      paused: false,
      lastTs: null,
      intervals: [], // ms
      maxIntervals: 200,
      count: 0,
      log: [],
      maxLog: 200,
      seqStop: false,
      rmsMax: Array(N).fill(0),
      peakMax: Array(N).fill(0),
    };

    function devFillApi(kind) {
      const method = document.getElementById('apiMethod');
      const path = document.getElementById('apiPath');
      const body = document.getElementById('apiBody');
      if (kind === 'state') { method.value = 'GET'; path.value = '/api/state'; body.value = ''; }
      if (kind === 'config') { method.value = 'GET'; path.value = '/api/config'; body.value = ''; }
      if (kind === 'select') { method.value = 'POST'; path.value = '/api/select/1'; body.value = '{}'; }
      if (kind === 'gaindb') { method.value = 'POST'; path.value = '/api/gain/1'; body.value = '{"gain_db": -6}'; }
      if (kind === 'mute') { method.value = 'POST'; path.value = '/api/mute/1'; body.value = '{"mute": true}'; }
    }

    // dev tabs handled by DevTools.setTab()

    function devOnWs(payload) {
      const now = Date.now();
      if (dev.lastTs != null) {
        const dt = now - dev.lastTs;
        dev.intervals.push(dt);
        if (dev.intervals.length > dev.maxIntervals) dev.intervals.shift();
      }
      dev.lastTs = now;
      dev.count += 1;
      // track maxima
      if (payload && payload.vu_rms && payload.vu_peak) {
        for (let i = 0; i < Math.min(N, payload.vu_rms.length); i++) {
          dev.rmsMax[i] = Math.max(dev.rmsMax[i], payload.vu_rms[i] || 0);
          dev.peakMax[i] = Math.max(dev.peakMax[i], payload.vu_peak[i] || 0);
        }
      }
      // log line
      try {
        const line = JSON.stringify({ t: now, payload });
        dev.log.push(line);
        if (dev.log.length > dev.maxLog) dev.log.shift();
        if (!dev.paused) {
          const el = document.getElementById('wsLog');
          if (el) {
            const ts = new Date(now).toLocaleTimeString();
            const short = JSON.stringify(payload).slice(0, 200);
            const div = document.createElement('div');
            div.textContent = `[${ts}] ${short}`;
            el.appendChild(div);
            // trim dom children
            while (el.childNodes.length > dev.maxLog) el.removeChild(el.firstChild);
            el.scrollTop = el.scrollHeight;
          }
        }
      } catch (_) {}
      devUpdateMetrics();
    }

    function devUpdateMetrics() {
      const cnt = dev.count;
      const avg = dev.intervals.length ? (dev.intervals.reduce((a,b)=>a+b,0) / dev.intervals.length) : 0;
      const min = dev.intervals.length ? Math.min(...dev.intervals) : 0;
      const max = dev.intervals.length ? Math.max(...dev.intervals) : 0;
      const rate = avg > 0 ? (1000 / avg) : 0;
      const last = dev.lastTs ? new Date(dev.lastTs).toLocaleTimeString() : '-';
      const wsCount = document.getElementById('wsCount'); if (wsCount) wsCount.value = String(cnt);
      const wsAvg = document.getElementById('wsAvg'); if (wsAvg) wsAvg.value = avg.toFixed(1);
      const wsMinMax = document.getElementById('wsMinMax'); if (wsMinMax) wsMinMax.value = `${min.toFixed(1)} / ${max.toFixed(1)}`;
      const wsRate = document.getElementById('wsRate'); if (wsRate) wsRate.value = rate.toFixed(2);
      const wsLastTime = document.getElementById('wsLastTime'); if (wsLastTime) wsLastTime.value = last;
      // metrics tab content
      const mc = document.getElementById('metricsContent');
      if (mc) {
        const toDb = v => 20 * Math.log10(Math.max(1e-9, v));
        const rmsDb = dev.rmsMax.map(toDb).map(v=>v.toFixed(1));
        const peakDb = dev.peakMax.map(toDb).map(v=>v.toFixed(1));
        mc.textContent = [
          `WS messages: ${cnt}`,
          `Avg dt: ${avg.toFixed(1)} ms (min ${min.toFixed(1)}, max ${max.toFixed(1)})`,
          `Approx rate: ${rate.toFixed(2)} Hz`,
          `Last: ${last}`,
          `RMS max (dB): [${rmsDb.join(', ')}]`,
          `Peak max (dB): [${peakDb.join(', ')}]`
        ].join('\n');
      }
    }

    function devWsToggle() {
      dev.paused = !dev.paused;
      const b = document.getElementById('wsPauseBtn');
      if (b) b.textContent = dev.paused ? 'Resume logging' : 'Pause logging';
    }
    function devWsClear() {
      dev.log = [];
      const el = document.getElementById('wsLog'); if (el) el.innerHTML = '';
    }
    function devWsCopyLast() {
      if (!dev.log.length) return;
      const last = dev.log[dev.log.length - 1];
      if (navigator.clipboard && navigator.clipboard.writeText) navigator.clipboard.writeText(last);
      else {
        const ta = document.createElement('textarea'); ta.value = last; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); document.body.removeChild(ta);
      }
    }
    function devWsDownload() {
      const blob = new Blob([dev.log.join('\n')], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = `ws_log_${Date.now()}.jsonl`; a.click();
      setTimeout(() => URL.revokeObjectURL(url), 1000);
    }

    async function devSeqStart(kind) {
      dev.seqStop = false;
      const status = document.getElementById('seqStatus');
      const log = (msg) => { if (status) { const line = document.createElement('div'); line.textContent = msg; status.appendChild(line); status.scrollTop = status.scrollHeight; } };
      if (kind === 'cycle') {
        const delay = parseInt(document.getElementById('seqCycleDelay').value || '500', 10);
        const loops = parseInt(document.getElementById('seqCycleLoops').value || '1', 10);
        log(`Start cycle: delay ${delay} ms, loops ${loops}`);
        for (let L = 0; L < loops && !dev.seqStop; L++) {
          for (let i = 1; i <= N && !dev.seqStop; i++) {
            await selectChannel(i);
            log(`Select CH ${i}`);
            await new Promise(r => setTimeout(r, delay));
          }
        }
        log('Cycle done.');
      }
      if (kind === 'ramp') {
        const min = parseFloat(document.getElementById('seqRampMin').value || '-18');
        const max = parseFloat(document.getElementById('seqRampMax').value || '0');
        const step = parseFloat(document.getElementById('seqRampStep').value || '3');
        const delay = parseInt(document.getElementById('seqRampDelay').value || '200', 10);
        log(`Start ramp: ${min}..${max} dB step ${step}, delay ${delay} ms`);
        const values = [];
        for (let v = min; v <= max + 1e-9; v += step) values.push(v);
        for (let i = 1; i <= N && !dev.seqStop; i++) {
          for (const v of values) {
            if (dev.seqStop) break;
            await setGainDb(i, v);
            log(`CH ${i} gain ${v.toFixed(1)} dB`);
            await new Promise(r => setTimeout(r, delay));
          }
        }
        log('Ramp done.');
      }
      if (kind === 'mute') {
        const delay = parseInt(document.getElementById('seqMuteDelay').value || '500', 10);
        log('Mute all');
        for (let i = 1; i <= N; i++) { if (dev.seqStop) break; await setMute(i, true); }
        await new Promise(r => setTimeout(r, delay));
        log('Unmute all');
        for (let i = 1; i <= N; i++) { if (dev.seqStop) break; await setMute(i, false); }
        log('Mute/unmute sequence done.');
      }
    }
    function devSeqStopAll() { dev.seqStop = true; const status = document.getElementById('seqStatus'); if (status) { const d = document.createElement('div'); d.textContent = 'STOP requested'; status.appendChild(d); } }

    // Init
    initState();
    wsConnect();

    // ----- Testljud (WAV generation + feed) -----
    const devWavs = { mapping: {}, listedAt: 0 };
    function logTA(msg) { const el = document.getElementById('testAudioLog'); if (el) { const d = document.createElement('div'); d.textContent = msg; el.appendChild(d); el.scrollTop = el.scrollHeight; } }
    async function genTestWavs() {
      try {
        const r = await fetch('/api/tools/generate_wavs', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ seconds: 2.0, samplerate: 48000 }) });
        const j = await r.json();
        if (!r.ok) throw new Error(JSON.stringify(j));
        logTA(`Genererade: ${j.files.join(', ')}`);
        await refreshWavsList();
      } catch (e) { logTA(`Fel vid generering: ${e}`); }
    }
    async function refreshWavsList() {
      try {
        const r = await fetch('/api/tools/wavs');
        const j = await r.json();
        devWavs.mapping = j.files || {};
        devWavs.listedAt = Date.now();
        // populate selects
        const chSel = document.getElementById('inFeedChannel');
        const fileSel = document.getElementById('inFeedFile');
        if (chSel && fileSel) {
          chSel.innerHTML = '';
          for (let i = 1; i <= N; i++) {
            const opt = document.createElement('option'); opt.value = String(i); opt.textContent = `CH ${i}`; chSel.appendChild(opt);
          }
          onInChannelChange();
        }
      } catch (e) { logTA(`Fel vid listning av WAVs: ${e}`); }
    }
    function onInChannelChange() {
      const ch = parseInt(document.getElementById('inFeedChannel').value || '1', 10);
      const fileSel = document.getElementById('inFeedFile');
      const files = (devWavs.mapping && devWavs.mapping[ch]) ? devWavs.mapping[ch] : [];
      fileSel.innerHTML = '';
      for (const f of files) { const opt = document.createElement('option'); opt.value = f; opt.textContent = f; fileSel.appendChild(opt); }
    }
    async function startFeedSelected() {
      const ch = parseInt(document.getElementById('inFeedChannel').value || '1', 10);
      const file = document.getElementById('inFeedFile').value;
      const loop = document.getElementById('inFeedLoop').value === 'true';
      const gain = parseFloat(document.getElementById('inFeedGain').value || '0');
      if (!file) { logTA('Ingen fil vald. Klicka "Generera test-WAVs" f√∂rst.'); return; }
      try {
        const r = await fetch('/api/tools/feed/start', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ file, input: ch, loop, gain_db: gain }) });
        const j = await r.json();
        if (!r.ok) throw new Error(JSON.stringify(j));
        logTA(`Startade feed CH ${ch} (pid=${j.pid})`);
      } catch (e) { logTA(`Fel vid start av feed: ${e}`); }
    }
    async function stopFeedSelected() {
      const ch = parseInt(document.getElementById('inFeedChannel').value || '1', 10);
      try {
        const r = await fetch('/api/tools/feed/stop', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ input: ch }) });
        await r.json();
        logTA(`Stoppade feed CH ${ch}`);
      } catch (e) { logTA(`Fel vid stopp: ${e}`); }
    }
    async function stopAllFeeds() {
      for (let i = 1; i <= N; i++) {
        try { await fetch('/api/tools/feed/stop', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ input: i }) }); } catch {}
      }
      logTA('Stoppa alla feedar: skickat.');
    }
    async function ensureWavsOrGenerate() {
      await refreshWavsList();
      let any = false;
      for (let i = 1; i <= N; i++) if (devWavs.mapping[i] && devWavs.mapping[i].length) { any = true; break; }
      if (!any) await genTestWavs();
      await refreshWavsList();
    }
    async function feedSequence() {
      await ensureWavsOrGenerate();
      const delay = parseInt(document.getElementById('outCycleDelay').value || '800', 10);
      let prev = 0;
      for (let i = 1; i <= N; i++) {
        if (prev) { try { await fetch('/api/tools/feed/stop', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ input: prev }) }); } catch {} }
        const files = devWavs.mapping[i] || [];
        if (!files.length) { logTA(`Ingen WAV f√∂r CH ${i}`); continue; }
        const file = files[0];
        await fetch('/api/tools/feed/start', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ file, input: i, loop: true }) });
        logTA(`Feed -> CH ${i}: ${file}`);
        await new Promise(r => setTimeout(r, delay));
        prev = i;
      }
    }
    async function headsetCycle() {
      const delay = parseInt(document.getElementById('outCycleDelay').value || '800', 10);
      for (let i = 1; i <= N; i++) { await selectChannel(i); logTA(`Headset v√§lj CH ${i}`); await new Promise(r => setTimeout(r, delay)); }
    }
    async function feedAndHeadsetSequence() {
      await ensureWavsOrGenerate();
      const delay = parseInt(document.getElementById('outCycleDelay').value || '800', 10);
      let prev = 0;
      for (let i = 1; i <= N; i++) {
        if (prev) { try { await fetch('/api/tools/feed/stop', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ input: prev }) }); } catch {} }
        const files = devWavs.mapping[i] || [];
        if (!files.length) { logTA(`Ingen WAV f√∂r CH ${i}`); continue; }
        const file = files[0];
        await fetch('/api/tools/feed/start', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ file, input: i, loop: true }) });
        await selectChannel(i);
        logTA(`Feed + headset -> CH ${i}: ${file}`);
        await new Promise(r => setTimeout(r, delay));
        prev = i;
      }
    }
    
    // ----- Custom Audio Upload Functions -----
    let selectedFile = null;
    let uploadedFiles = [];
    
    function handleFileSelect(event) {
      const files = event.target.files;
      if (files.length > 0) {
        selectedFile = files[0];
        const status = document.getElementById('uploadStatus');
        status.textContent = `Vald fil: ${selectedFile.name} (${(selectedFile.size / 1024 / 1024).toFixed(2)} MB)`;
      }
    }
    
    async function uploadSelectedFile() {
      if (!selectedFile) {
        document.getElementById('uploadStatus').textContent = 'Ingen fil vald';
        return;
      }
      
      const status = document.getElementById('uploadStatus');
      status.textContent = 'Laddar upp...';
      
      const formData = new FormData();
      formData.append('file', selectedFile);
      
      try {
        const response = await fetch('/api/upload/audio', {
          method: 'POST',
          body: formData
        });
        
        const result = await response.json();
        
        if (response.ok) {
          status.textContent = `‚úÖ Uppladdad: ${result.original_name} (${result.duration.toFixed(1)}s @ ${result.samplerate} Hz)`;
          await refreshUploadedFiles();
          selectedFile = null;
          document.getElementById('audioFileInput').value = '';
        } else {
          status.textContent = `‚ùå Fel: ${result.detail}`;
        }
      } catch (error) {
        status.textContent = `‚ùå Uppladdningsfel: ${error.message}`;
      }
    }
    
    async function refreshUploadedFiles() {
      try {
        const response = await fetch('/api/upload/list');
        const result = await response.json();
        uploadedFiles = result.files || [];
        
        const select = document.getElementById('uploadedFilesList');
        select.innerHTML = '';
        
        if (uploadedFiles.length === 0) {
          const opt = document.createElement('option');
          opt.value = '';
          opt.textContent = 'Inga uppladdade filer';
          select.appendChild(opt);
        } else {
          uploadedFiles.forEach(file => {
            const opt = document.createElement('option');
            opt.value = file.filename;
            opt.textContent = `${file.filename} (${file.duration.toFixed(1)}s)`;
            select.appendChild(opt);
          });
        }
        
        selectUploadedFile();
      } catch (error) {
        logUpload(`Fel vid h√§mtning av filer: ${error.message}`);
      }
    }
    
    function selectUploadedFile() {
      const select = document.getElementById('uploadedFilesList');
      const info = document.getElementById('uploadedFileInfo');
      
      if (!select.value || uploadedFiles.length === 0) {
        info.textContent = '';
        return;
      }
      
      const file = uploadedFiles.find(f => f.filename === select.value);
      if (file) {
        info.textContent = `L√§ngd: ${file.duration.toFixed(1)}s, ${file.samplerate} Hz, ${file.channels} kanal(er)`;
      }
    }
    
    async function deleteUploadedFile() {
      const select = document.getElementById('uploadedFilesList');
      const filename = select.value;
      
      if (!filename) {
        alert('V√§lj en fil att ta bort');
        return;
      }
      
      if (!confirm(`Ta bort ${filename}?`)) {
        return;
      }
      
      try {
        const response = await fetch(`/api/upload/${filename}`, {
          method: 'DELETE'
        });
        
        if (response.ok) {
          logUpload(`Tog bort: ${filename}`);
          await refreshUploadedFiles();
        } else {
          const error = await response.json();
          logUpload(`Fel vid borttagning: ${error.detail}`);
        }
      } catch (error) {
        logUpload(`Fel: ${error.message}`);
      }
    }
    
    async function startUploadedPlayback() {
      const select = document.getElementById('uploadedFilesList');
      const filename = select.value;
      
      if (!filename) {
        logUpload('V√§lj en fil att spela');
        return;
      }
      
      const file = uploadedFiles.find(f => f.filename === filename);
      if (!file) {
        logUpload('Fil inte funnen');
        return;
      }
      
      const channel = parseInt(document.getElementById('uploadPlayChannel').value);
      const loop = document.getElementById('uploadPlayLoop').value === 'true';
      const gain = parseFloat(document.getElementById('uploadPlayGain').value || '0');
      
      try {
        const response = await fetch('/api/tools/feed/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            file: file.path,
            input: channel,
            loop: loop,
            gain_db: gain
          })
        });
        
        const result = await response.json();
        
        if (response.ok) {
          logUpload(`‚ñ∂ Spelar "${file.filename}" p√• kanal ${channel} (PID: ${result.pid})`);
        } else {
          logUpload(`Fel: ${result.detail}`);
        }
      } catch (error) {
        logUpload(`Fel vid uppspelning: ${error.message}`);
      }
    }
    
    async function stopUploadedPlayback() {
      const channel = parseInt(document.getElementById('uploadPlayChannel').value);
      
      try {
        const response = await fetch('/api/tools/feed/stop', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ input: channel })
        });
        
        if (response.ok) {
          logUpload(`‚èπ Stoppade uppspelning p√• kanal ${channel}`);
        }
      } catch (error) {
        logUpload(`Fel vid stopp: ${error.message}`);
      }
    }
    
    function logUpload(msg) {
      const el = document.getElementById('uploadPlayLog');
      if (el) {
        const d = document.createElement('div');
        d.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
        el.appendChild(d);
        el.scrollTop = el.scrollHeight;
      }
    }
    
    async function playUploadedFile() {
      await startUploadedPlayback();
    }
    
    // Initialize uploaded files list on page load
    setTimeout(() => {
      if (document.getElementById('uploadedFilesList')) {
        refreshUploadedFiles();
      }
    }, 500);
    
    // ----- Output Channel Testing Functions -----
    async function testAllOutputChannels() {
      logTA('Startar test av alla 8 utg√•ngskanaler...');
      await ensureWavsOrGenerate();
      const delay = parseInt(document.getElementById('outCycleDelay').value || '800', 10);
      
      // Test each input channel routed to outputs
      for (let inputCh = 1; inputCh <= 6; inputCh++) {
        const files = devWavs.mapping[inputCh] || [];
        if (!files.length) {
          logTA(`Ingen WAV f√∂r ing√•ng ${inputCh}, hoppar √∂ver`);
          continue;
        }
        
        const file = files[0];
        
        // Start feed on input channel
        try {
          await fetch('/api/tools/feed/start', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ file, input: inputCh, loop: true })
          });
          
          // Select this input channel (routes to all 8 outputs)
          await selectChannel(inputCh);
          logTA(`üîä Ing√•ng ${inputCh} ‚Üí Alla 8 utg√•ngar: ${file}`);
          
          await new Promise(r => setTimeout(r, delay));
          
          // Stop feed
          await fetch('/api/tools/feed/stop', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ input: inputCh })
          });
          
        } catch (error) {
          logTA(`Fel vid test av ing√•ng ${inputCh}: ${error.message}`);
        }
      }
      
      logTA('Test av alla utg√•ngskanaler klart');
    }
    
    async function testSpecificOutput() {
      const outputChannel = parseInt(document.getElementById('outputChannelSelect').value);
      const outputNames = ['out_l', 'out_r', 'out_3', 'out_4', 'out_5', 'out_6', 'out_7', 'out_8'];
      const outputName = outputNames[outputChannel - 1] || `out_${outputChannel}`;
      
      logTA(`Testar specifik utg√•ng ${outputChannel} (${outputName})...`);
      await ensureWavsOrGenerate();
      
      // Use first available input channel with audio
      let testInputCh = 1;
      let testFile = null;
      
      for (let i = 1; i <= 6; i++) {
        const files = devWavs.mapping[i] || [];
        if (files.length > 0) {
          testInputCh = i;
          testFile = files[0];
          break;
        }
      }
      
      if (!testFile) {
        logTA('Ingen testfil tillg√§nglig');
        return;
      }
      
      try {
        // Start feed on test input
        await fetch('/api/tools/feed/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ file: testFile, input: testInputCh, loop: true })
        });
        
        // Select the input (routes to all outputs including the one we want to test)
        await selectChannel(testInputCh);
        
        logTA(`üéØ Test av utg√•ng ${outputChannel} (${outputName})`);
        logTA(`   Anv√§nder ing√•ng ${testInputCh}: ${testFile}`);
        logTA(`   Lyssna p√• utg√•ng ${outputChannel} f√∂r att verifiera ljud`);
        
        // Let it play for a while
        const delay = parseInt(document.getElementById('outCycleDelay').value || '800', 10);
        await new Promise(r => setTimeout(r, delay * 2));
        
        // Stop feed
        await fetch('/api/tools/feed/stop', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ input: testInputCh })
        });
        
        logTA(`Test av utg√•ng ${outputChannel} klart`);
        
      } catch (error) {
        logTA(`Fel vid test av utg√•ng ${outputChannel}: ${error.message}`);
      }
    }
    
    // Enhanced output channel cycling for all 8 outputs
    async function testOutputChannelCycle() {
      logTA('Startar cykel-test av alla 8 utg√•ngskanaler...');
      await ensureWavsOrGenerate();
      const delay = parseInt(document.getElementById('outCycleDelay').value || '800', 10);
      
      // Use different input channels for variety
      const inputChannels = [1, 2, 3, 4, 5, 6];
      
      for (let outputCh = 1; outputCh <= 8; outputCh++) {
        const inputCh = inputChannels[(outputCh - 1) % inputChannels.length];
        const files = devWavs.mapping[inputCh] || [];
        
        if (!files.length) continue;
        
        const file = files[0];
        const outputNames = ['out_l', 'out_r', 'out_3', 'out_4', 'out_5', 'out_6', 'out_7', 'out_8'];
        const outputName = outputNames[outputCh - 1] || `out_${outputCh}`;
        
        try {
          // Start feed
          await fetch('/api/tools/feed/start', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ file, input: inputCh, loop: true })
          });
          
          // Select input (routes to all outputs)
          await selectChannel(inputCh);
          
          logTA(`üîÑ Utg√•ng ${outputCh} (${outputName}) ‚Üê Ing√•ng ${inputCh}`);
          
          await new Promise(r => setTimeout(r, delay));
          
          // Stop feed
          await fetch('/api/tools/feed/stop', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ input: inputCh })
          });
          
        } catch (error) {
          logTA(`Fel vid cykel-test utg√•ng ${outputCh}: ${error.message}`);
        }
      }
      
      logTA('Cykel-test av alla utg√•ngar klart');
    }
    
    // ----- Automated Audio Testing Functions -----
    async function runAutomaticOutputTest() {
      logTA('ü§ñ Startar automatiskt ljudtest av alla utg√•ngskanaler...');
      logTA('Detta test anv√§nder distinkta toner f√∂r varje kanal');
      
      try {
        const response = await fetch('/api/test/output_channels', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        });
        
        const result = await response.json();
        
        if (result.success) {
          logTA('‚úÖ Automatiskt test genomf√∂rt framg√•ngsrikt!');
          if (result.output) {
            // Parse and display key parts of the output
            const lines = result.output.split('\n');
            lines.forEach(line => {
              if (line.includes('TEST') || line.includes('‚úÖ') || line.includes('‚ùå') || 
                  line.includes('SUMMARY') || line.includes('Channel')) {
                logTA(line);
              }
            });
          }
        } else {
          logTA('‚ùå Automatiskt test misslyckades');
          if (result.error) {
            logTA(`Fel: ${result.error}`);
          }
        }
        
      } catch (error) {
        logTA(`‚ùå Fel vid automatiskt test: ${error.message}`);
      }
    }
    
    async function generateTestAudio() {
      logTA('üéµ Genererar testljudfiler...');
      
      try {
        const response = await fetch('/api/test/generate_test_audio', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        });
        
        const result = await response.json();
        
        if (result.success) {
          logTA('‚úÖ Testljudfiler genererade framg√•ngsrikt!');
          logTA(`Skapade ${result.files.length} filer:`);
          result.files.forEach(file => {
            logTA(`  - ${file}`);
          });
          logTA('Filerna kan nu anv√§ndas f√∂r manuell testning');
        } else {
          logTA('‚ùå Misslyckades att generera testljudfiler');
          if (result.error) {
            logTA(`Fel: ${result.error}`);
          }
        }
        
      } catch (error) {
        logTA(`‚ùå Fel vid generering av testljud: ${error.message}`);
      }
    }
  </script>
</body>
</html>
